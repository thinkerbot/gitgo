From news@gmane.org Tue Mar 04 03:33:20 2003
From: "Andrew Timberlake-Newell" 
	<Andrew.Timberlake-Newell@AllianceOneInc.com>
Subject: RE: missing: git api, reference, user manual and mission statement
Date: Wed, 20 Apr 2005 13:15:46 -0400
Lines: 33
Message-ID: <004e01c545cc$97d9b780$9b11a8c0@allianceoneinc.com>
References: <20050419165809.GE12757@pasky.ji.cz>
Mime-Version: 1.0
Content-Type: text/plain;
	charset="us-ascii"
Content-Transfer-Encoding: 8BIT
Cc: "'Petr Baudis'" <pasky@ucw.cz>
X-From: git-owner@vger.kernel.org Wed Apr 20 19:15:05 2005
Return-path: <git-owner@vger.kernel.org>
Received: from vger.kernel.org ([12.107.209.244])
	by ciao.gmane.org with esmtp (Exim 4.43)
	id 1DOIlv-0002yn-Me
	for gcvg-git@gmane.org; Wed, 20 Apr 2005 19:13:55 +0200
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S261739AbVDTRRi (ORCPT <rfc822;gcvg-git@m.gmane.org>);
	Wed, 20 Apr 2005 13:17:38 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S261749AbVDTRRi
	(ORCPT <rfc822;git-outgoing>); Wed, 20 Apr 2005 13:17:38 -0400
Received: from mail.allianceoneinc.com ([65.213.221.36]:61445 "EHLO
	mail.allianceoneinc.com") by vger.kernel.org with ESMTP
	id S261739AbVDTRQl convert rfc822-to-8bit (ORCPT
	<rfc822;git@vger.kernel.org>); Wed, 20 Apr 2005 13:16:41 -0400
Received: from epa20012 [192.168.17.155] by mail.allianceoneinc.com with ESMTP
  (SMTPD32-8.14) id AE424C300B4; Wed, 20 Apr 2005 13:15:46 -0400
To: <git@vger.kernel.org>
X-Priority: 3 (Normal)
X-MSMail-Priority: Normal
X-Mailer: Microsoft Outlook, Build 10.0.6626
In-Reply-To: <20050419165809.GE12757@pasky.ji.cz>
X-MimeOLE: Produced By Microsoft MimeOLE V6.00.2900.2180
Importance: Normal
X-IMAIL-SPAM-VALFROM: (8e4204c300b4b26c)
Sender: git-owner@vger.kernel.org
Precedence: bulk
X-Mailing-List: git@vger.kernel.org
Status: RO

Petr Baudis graced us with:
> Dear diary, on Tue, Apr 19, 2005 at 02:36:32PM CEST, I got a letter
> where Klaus Robert Suetterlin <robert@mpe.mpg.de> told me that...
> > 1) There is no clear (e.g. by name) distinction between ``git as done
> > by Linus'', which is a kind of content addressable database with added
> > semantics, and ``git as done by the rest of You'', which is a kind of
> > SCM on top of Linuses stuff.
> 
> There is git and git-pasky (git-pasky is superset; therefore various
> patches floating around either get to git-pasky or to both). I'm not
> sure what else do you mean.

This goes back to the question of whether to rename git-pasky to cogito.  

Perhaps the crucial question is:  will the git plumbing be used for anything
other than SCM?

If so, then it could be useful to differentiate by program name, so that we
would know whether another project was utilizing git-plumbing or git-SCM.

If not, then there is effectively only one tool and the plumbing is a
[crucial] portion thereof:  a git (SCM and the file system around which it
was built).

So what's the answer to the question?  Anyone planning to use git (the file
system) outside of the SCM?


-
To unsubscribe from this list: send the line "unsubscribe git" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html



From news@gmane.org Tue Mar 04 03:33:20 2003
From: "C. Scott Ananian" <cscott@cscott.net>
Subject: Re: [PATCH] Some documentation...
Date: Wed, 20 Apr 2005 13:24:18 -0400 (EDT)
Lines: 28
Message-ID: <Pine.LNX.4.61.0504201321380.2630@cag.csail.mit.edu>
References: <42668C8D.3000209@dgreaves.com>
Mime-Version: 1.0
Content-Type: TEXT/PLAIN; charset=US-ASCII; format=flowed
Cc: git@vger.kernel.org
X-From: git-owner@vger.kernel.org Wed Apr 20 19:23:20 2005
Return-path: <git-owner@vger.kernel.org>
Received: from vger.kernel.org ([12.107.209.244])
	by ciao.gmane.org with esmtp (Exim 4.43)
	id 1DOIuZ-0004Sx-S6
	for gcvg-git@gmane.org; Wed, 20 Apr 2005 19:22:52 +0200
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S261692AbVDTRZ5 (ORCPT <rfc822;gcvg-git@m.gmane.org>);
	Wed, 20 Apr 2005 13:25:57 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S261688AbVDTRZw
	(ORCPT <rfc822;git-outgoing>); Wed, 20 Apr 2005 13:25:52 -0400
Received: from sincerity-forever.csail.mit.edu ([128.30.67.31]:2713 "EHLO
	sincerity-forever.csail.mit.edu") by vger.kernel.org with ESMTP
	id S261765AbVDTRYf (ORCPT <rfc822;git@vger.kernel.org>);
	Wed, 20 Apr 2005 13:24:35 -0400
Received: from catfish.lcs.mit.edu ([128.30.67.25] helo=cag.csail.mit.edu)
	by sincerity-forever.csail.mit.edu with esmtp (Exim 3.36 #1 (Debian))
	id 1DOIw9-0001KX-00; Wed, 20 Apr 2005 13:24:29 -0400
To: David Greaves <david@dgreaves.com>
In-Reply-To: <42668C8D.3000209@dgreaves.com>
Sender: git-owner@vger.kernel.org
Precedence: bulk
X-Mailing-List: git@vger.kernel.org
Status: RO

On Wed, 20 Apr 2005, David Greaves wrote:

> In doing this I noticed a couple of points:
> * update-cache won't accept ./file or fred/./file

The comment in update-cache.c reads:
/*
  * We fundamentally don't like some paths: we don't want
  * dot or dot-dot anywhere, and in fact, we don't even want
  * any other dot-files (.git or anything else). They
  * are hidden, for chist sake.
  *
  * Also, we don't want double slashes or slashes at the
  * end that can make pathnames ambiguous.
  */

It could be argued that './' is a special case... but at the moment this 
is definitely a designed 'feature' not a 'bug'.
  --scott

BLUEBIRD SEQUIN SECANT Waihopai Honduras KUDOVE genetic KUJUMP SCRANTON 
DES AMLASH Indonesia SLINC cracking ESMERALDITE mustard Uzi KUSODA
                          ( http://cscott.net/ )
-
To unsubscribe from this list: send the line "unsubscribe git" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html



From news@gmane.org Tue Mar 04 03:33:20 2003
From: Zlatko Calusic <zlatko.calusic@iskon.hr>
Subject: Re: [script] ge: export commits as patches
Date: Wed, 20 Apr 2005 19:21:43 +0200
Lines: 20
Message-ID: <dn7jix8iu0.fsf@magla.zg.iskon.hr>
References: <20050419134843.GA19146@elte.hu>
Reply-To: zlatko.calusic@iskon.hr
Mime-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Cc: Petr Baudis <pasky@ucw.cz>, git@vger.kernel.org
X-From: git-owner@vger.kernel.org Wed Apr 20 19:23:47 2005
Return-path: <git-owner@vger.kernel.org>
Received: from vger.kernel.org ([12.107.209.244])
	by ciao.gmane.org with esmtp (Exim 4.43)
	id 1DOIuZ-0004Sx-Cb
	for gcvg-git@gmane.org; Wed, 20 Apr 2005 19:22:51 +0200
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S261742AbVDTRZa (ORCPT <rfc822;gcvg-git@m.gmane.org>);
	Wed, 20 Apr 2005 13:25:30 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S261749AbVDTRWx
	(ORCPT <rfc822;git-outgoing>); Wed, 20 Apr 2005 13:22:53 -0400
Received: from mxout2.iskon.hr ([213.191.128.16]:33707 "HELO mxout2.iskon.hr")
	by vger.kernel.org with SMTP id S261762AbVDTRVu (ORCPT
	<rfc822;git@vger.kernel.org>); Wed, 20 Apr 2005 13:21:50 -0400
Received: (qmail 18107 invoked from network); 20 Apr 2005 19:21:44 +0200
X-Remote-IP: 213.191.142.124
Received: from unknown (HELO mx.iskon.hr) (213.191.142.124)
  by mxout2.iskon.hr with SMTP; 20 Apr 2005 19:21:44 +0200
Received: (qmail 7320 invoked from network); 20 Apr 2005 19:21:44 +0200
X-Remote-IP: 213.191.128.21
Received: from oganj.iskon.hr (HELO magla.zg.iskon.hr) (213.191.128.21)
  by mx.iskon.hr with SMTP; 20 Apr 2005 19:21:43 +0200
Received: (qmail 5501 invoked by uid 804); 20 Apr 2005 19:21:43 +0200
To: Ingo Molnar <mingo@elte.hu>
X-Face: s71Vs\G4I3mB$X2=P4h[aszUL\%"`1!YRYl[JGlC57kU-`kxADX}T/Bq)Q9.$fGh7lFNb.s
 i&L3xVb:q_Pr}>Eo(@kU,c:3:64cR]m@27>1tGl1):#(bs*Ip0c}N{:JGcgOXd9H'Nwm:}jLr\FZtZ
 pri/C@\,4lW<|jrq^<):Nk%Hp@G&F"r+n1@BoH
In-Reply-To: <20050419134843.GA19146@elte.hu> (Ingo Molnar's message of
 "Tue, 19 Apr 2005 15:48:43 +0200")
User-Agent: Gnus/5.1007 (Gnus v5.10.7) XEmacs/21.4 (Jumbo Shrimp, linux)
Sender: git-owner@vger.kernel.org
Precedence: bulk
X-Mailing-List: git@vger.kernel.org
Status: RO

Ingo Molnar <mingo@elte.hu> writes:

> TREE1=$(cat-file commit 2>/dev/null $1 | head -4 | grep ^tree | cut -d' ' -f2)
                                         --------------------------------------

And to make it easier on your eyes, you can always rewrite stuff like
that (mentioned everywhere these days :)) like:

TREE1=$(cat-file commit 2>/dev/null $1 | awk '/^tree/ {print $2}'
                                         ------------------------

No, I'm definitely not trying to save some CPU cycles, CPU cycles are
cheap, eyes are expensive! :)
-- 
Zlatko
-
To unsubscribe from this list: send the line "unsubscribe git" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html



From news@gmane.org Tue Mar 04 03:33:20 2003
From: Chris Mason <mason@suse.com>
Subject: Re: [PATCH] write-tree performance problems
Date: Wed, 20 Apr 2005 13:23:04 -0400
Lines: 103
Message-ID: <200504201323.05447.mason@suse.com>
References: <200504191250.10286.mason@suse.com> <200504201237.38374.mason@suse.com> <Pine.LNX.4.58.0504200957030.6467@ppc970.osdl.org>
Mime-Version: 1.0
Content-Type: Multipart/Mixed;
  boundary="Boundary-00=_5/oZCLJefJQcKIS"
Cc: git@vger.kernel.org
X-From: git-owner@vger.kernel.org Wed Apr 20 19:27:22 2005
Return-path: <git-owner@vger.kernel.org>
Received: from vger.kernel.org ([12.107.209.244])
	by ciao.gmane.org with esmtp (Exim 4.43)
	id 1DOIxr-00053Y-Of
	for gcvg-git@gmane.org; Wed, 20 Apr 2005 19:26:16 +0200
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S261754AbVDTR3q (ORCPT <rfc822;gcvg-git@m.gmane.org>);
	Wed, 20 Apr 2005 13:29:46 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S261735AbVDTR1O
	(ORCPT <rfc822;git-outgoing>); Wed, 20 Apr 2005 13:27:14 -0400
Received: from cantor2.suse.de ([195.135.220.15]:61830 "EHLO mx2.suse.de")
	by vger.kernel.org with ESMTP id S261762AbVDTRXK (ORCPT
	<rfc822;git@vger.kernel.org>); Wed, 20 Apr 2005 13:23:10 -0400
Received: from extimap.suse.de (extimap.suse.de [195.135.220.6])
	(using TLSv1 with cipher EDH-RSA-DES-CBC3-SHA (168/168 bits))
	(No client certificate requested)
	by mx2.suse.de (Postfix) with ESMTP id E26E79177;
	Wed, 20 Apr 2005 19:23:07 +0200 (CEST)
Received: from watt.suse.com (cpe-66-66-175-36.rochester.res.rr.com [66.66.175.36])
	(using TLSv1 with cipher RC4-MD5 (128/128 bits))
	(Client did not present a certificate)
	by extimap.suse.de (Postfix) with ESMTP
	id 6CF0F14CD96; Wed, 20 Apr 2005 19:23:07 +0200 (CEST)
To: Linus Torvalds <torvalds@osdl.org>
User-Agent: KMail/1.8
In-Reply-To: <Pine.LNX.4.58.0504200957030.6467@ppc970.osdl.org>
Sender: git-owner@vger.kernel.org
Precedence: bulk
X-Mailing-List: git@vger.kernel.org
Status: RO

--Boundary-00=_5/oZCLJefJQcKIS
Content-Type: text/plain;
  charset="iso-8859-1"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

On Wednesday 20 April 2005 13:06, Linus Torvalds wrote:
> On Wed, 20 Apr 2005, Chris Mason wrote:
> > At any rate, the time for a single write-tree is pretty consistent. 
> > Before it was around .5 seconds, and with this change it goes down to
> > .128s.
>
> Oh, wow.
>
> I bet your SHA1 implementation is done with hand-optimized and scheduled
> x86 MMX code or something, while my poor G5 is probably using some slow
> generic routine. As a result, it only improved by 33% for me since the
> compression was just part of the picture, but with your cheap SHA1 the
> compression costs really dominated, and so it's almost four times faster
> for you.

Aha, I was wondering why your write-tree speeds sounded so bad...this athlon 
machine is ~2years old now.

Your comments about costs for writing the index file got me thinking, so I 
benchmarked how long the update-cache takes if we don't do the sha1 of the 
index file.  There was almost no difference at all.  update-cache currently 
takes about .152 seconds

The code to write the cache calls write() for every cache entry, writing just 
a few bytes at a time.  I changed it to collect these into a 16k buffer, 
which brings me down to .044s.  This might not help as much on ext23, since 
they are faster than reiser for tiny writes.

The patch below with your current tree brings my 100 patch test down to 22 
seconds again.

-chris

--Boundary-00=_5/oZCLJefJQcKIS
Content-Type: text/x-diff;
  charset="iso-8859-1";
  name="read-cache-fast.diff"
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment;
	filename="read-cache-fast.diff"

--- linus.back/read-cache.c	2005-04-20 10:14:23.268310000 -0400
+++ linus/read-cache.c	2005-04-20 13:05:13.200083672 -0400
@@ -232,11 +232,12 @@
 	SHA_CTX c;
 	struct cache_header hdr;
 	int i;
+	char *buf;
+	int len = 0;
 
 	hdr.hdr_signature = htonl(CACHE_SIGNATURE);
 	hdr.hdr_version = htonl(1);
 	hdr.hdr_entries = htonl(entries);
-
 	SHA1_Init(&c);
 	SHA1_Update(&c, &hdr, offsetof(struct cache_header, sha1));
 	for (i = 0; i < entries; i++) {
@@ -246,13 +247,31 @@
 	}
 	SHA1_Final(hdr.sha1, &c);
 
+	buf = malloc(16384);
+	if (!buf) {
+		return -1;
+	}
 	if (write(newfd, &hdr, sizeof(hdr)) != sizeof(hdr))
 		return -1;
 
 	for (i = 0; i < entries; i++) {
 		struct cache_entry *ce = cache[i];
 		int size = ce_size(ce);
-		if (write(newfd, ce, size) != size)
+		if (size > 16384) {
+			if (write(newfd, ce, size) != size)
+				return -1;
+			continue;
+		}
+		if (len + size > 16384) {
+			if (write(newfd, buf, len) != len)
+				return -1;
+			len = 0;
+		}
+		memcpy(buf + len, ce, size);
+		len += size;
+	}
+	if (len) {
+		if (write(newfd, buf, len) != len)
 			return -1;
 	}
 	return 0;

--Boundary-00=_5/oZCLJefJQcKIS--
-
To unsubscribe from this list: send the line "unsubscribe git" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html



From news@gmane.org Tue Mar 04 03:33:20 2003
From: "C. Scott Ananian" <cscott@cscott.net>
Subject: Blob chunking code. [Second look]
Date: Wed, 20 Apr 2005 13:31:07 -0400 (EDT)
Lines: 593
Message-ID: <Pine.LNX.4.61.0504201325550.2630@cag.csail.mit.edu>
References: <200504191250.10286.mason@suse.com> <200504191708.23536.mason@suse.com>
 <Pine.LNX.4.58.0504191420060.19286@ppc970.osdl.org> <200504192049.21947.mason@suse.com>
 <Pine.LNX.4.58.0504192337120.6467@ppc970.osdl.org> <42660708.60109@zytor.com>
 <Pine.LNX.4.58.0504200144260.6467@ppc970.osdl.org>
 <Pine.LNX.4.61.0504200917070.28851@cag.csail.mit.edu>
Mime-Version: 1.0
Content-Type: TEXT/PLAIN; charset=US-ASCII; format=flowed
X-From: git-owner@vger.kernel.org Wed Apr 20 19:32:05 2005
Return-path: <git-owner@vger.kernel.org>
Received: from vger.kernel.org ([12.107.209.244])
	by ciao.gmane.org with esmtp (Exim 4.43)
	id 1DOJ2Y-0005qN-DR
	for gcvg-git@gmane.org; Wed, 20 Apr 2005 19:31:06 +0200
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S261743AbVDTRfO (ORCPT <rfc822;gcvg-git@m.gmane.org>);
	Wed, 20 Apr 2005 13:35:14 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S261689AbVDTRfO
	(ORCPT <rfc822;git-outgoing>); Wed, 20 Apr 2005 13:35:14 -0400
Received: from sincerity-forever.csail.mit.edu ([128.30.67.31]:43673 "EHLO
	sincerity-forever.csail.mit.edu") by vger.kernel.org with ESMTP
	id S261774AbVDTRbU (ORCPT <rfc822;git@vger.kernel.org>);
	Wed, 20 Apr 2005 13:31:20 -0400
Received: from catfish.lcs.mit.edu ([128.30.67.25] helo=cag.csail.mit.edu)
	by sincerity-forever.csail.mit.edu with esmtp (Exim 3.36 #1 (Debian))
	id 1DOJ2k-0001O9-00
	for <git@vger.kernel.org>; Wed, 20 Apr 2005 13:31:18 -0400
To: Git Mailing List <git@vger.kernel.org>
In-Reply-To: <Pine.LNX.4.61.0504200917070.28851@cag.csail.mit.edu>
Sender: git-owner@vger.kernel.org
Precedence: bulk
X-Mailing-List: git@vger.kernel.org
Status: RO

Here's a quick rev of the chunking code.  This is compatible with 
git-current, where the hashes are of the *uncompressed* file.
The 'chunk' file gets dropped in at the same SHA1 filename as the
'blob' file, as it represents identical contents.  Martin won't like
this (because of how the hash is computed), but this is the short-term
direction I want to pursue to validate the concept: it means I can
run a simple converter over all the blob objects and don't have to
rewrite tree and commit objects.

If the approach is seen to have merit, then we can perhaps think about 
doing another bulk repository format conversion where all the hashes
change.  But (IMO) it's a little early to be thinking of this yet.
  --scott

nuclear RUCKUS KUPALM ODACID LA STANDEL Mossad LITEMPO atomic mail drop 
Hussein JUBILIST class struggle SSBN 731 Bush quiche Nazi MKULTRA
                          ( http://cscott.net/ )
---------  chunk.c ----------
/*
  * This file implements a treap-based chunked content store.  The
  * idea is that every stored file is broken down into tree-structured
  * chunks (that is, every chunk has an optional 'prefix' and 'suffix'
  * chunk), and these chunks are put in the object store.  This way
  * similar files will be expected to share chunks, saving space.
  * Files less than one disk block long are expected to fit in a single
  * chunk, so there is no extra indirection overhead for this case.
  *
  * Copyright (C) 2005 C. Scott Ananian <cananian@alumni.princeton.edu>
  */

/*
  * We assume that the file and the chunk information all fits in memory.
  * A slightly more-clever implementation would work even if the file
  * didn't fit.  Basically, we could scan it an keep the
  * 'N' lowest heap keys (chunk hashes), where 'N' is chosen to fit
  * comfortably in memory.  These would form the root and top
  * of the resulting treap, constructing it top-down.  Then we'd scan
  * again any only keep the next 'N' lowest heap keys, etc.
  *
  * But we're going to keep things simple.  We do try to maintain locality
  * where possible, so if you need to swap things still shouldn't be too bad.
  */

#include <assert.h>
#include <stdlib.h>
#include "cache.h"
#include "chunk.h"

typedef unsigned long ch_size_t;

/* Our magic numbers: these can be tuned without breaking files already
  * in the archive, although space re-use is only expected between files which
  * have these constants set to the same values. */

/* The window size determines how much context we use when looking for a
  * chunk boundary.
  * C source has approx 5 bits per character of entropy.
  * We'd like to get 32 bits of good entropy into our boundary checksum;
  * that means 7 bytes is a rough minimum for the window size.
  * 30 bytes is what 'rsyncable zlib' uses; that should be fine. */
#define ROLLING_WINDOW 30
/* The ideal chunk size will fit most chunks into a disk block.  A typical
  * disk block size is 4k, and we expect (say) 50% compression. */
#define CHUNK_SIZE 7901 /* primes are nice to use */

/* Data structures: */
struct chunk {
     /* a chunk represents some range of the underlying file */
     ch_size_t start /* inclusive */, end /*exclusive*/;
     unsigned char sha1[20]; /* sha1 for this chunk; used as the heap key */
};
struct chunklist {
     /* a dynamically-sized list of chunks */
     struct chunk *chunk; /* an array of chunks */
     ch_size_t num_items; /* how many items are currently in the list */
     ch_size_t allocd;    /* how many items we've allocated space for */
};
struct treap {
     /* A treap node represents a run of consecutive chunks. */

     /* the start and end of the run: */
     ch_size_t start /* inclusive */, end /*exclusive*/;
     struct chunk *chunk; /* some chunk in the run. */
     /* treaps representing the run before 'chunk' (left) and
      * after 'chunk' (right).  */
     struct treap *left, *right;
     /* sha1 for the run represented by this treap */
     unsigned char sha1[20];
};

static struct chunklist *
create_chunklist(int expected_items) {
     struct chunklist *cl = malloc(sizeof(*cl));
     cl->num_items = 0;
     cl->allocd = expected_items;
     cl->chunk = malloc(sizeof(cl->chunk[0]) * cl->allocd);
     return cl;
}
static void
free_chunklist(struct chunklist *cl) {
     free(cl->chunk);
     free(cl);
}

/* Add a chunk to the chunk list, calculating its SHA1 in the process. */
/* The chunk includes buf[start] to buf[end-1].                        */
static void
add_chunk(struct chunklist *cl, char *buf, ch_size_t start, ch_size_t end) {
     struct chunk *ch;
     SHA_CTX c;
     assert(start<end); assert(cl); assert(buf);
     if (cl->num_items >= cl->allocd) {
 	cl->allocd = cl->allocd*3/2;
 	cl->chunk = realloc(cl->chunk, cl->allocd * sizeof(*(cl->chunk)));
     }
     assert(cl->num_items < cl->allocd);
     ch = cl->chunk + (cl->num_items++);
     ch->start = start;
     ch->end = end;
     /* compute SHA-1 of the chunk. */
     SHA1_Init(&c);
     SHA1_Update(&c, buf+start, end-start);
     SHA1_Final(ch->sha1, &c);
     /* done! */
}

/* Split a buffer into chunks, using a rolling checksum over ROLLING_WINDOW
  * bytes to determine chunk boundaries.  We try to split chunks into pieces
  * whose size averages out to be 'CHUNK_SIZE'. */
static void
chunkify(struct chunklist *cl, char *buf, ch_size_t size) {
     int i, rsync_s1=0, rsync_s2=0, last=-1;
     /* While window is filling: */
     for (i=0; i<ROLLING_WINDOW && i<size; i++) {
 	/* add one to char so that leading 0s don't behave strangely. */
 	rsync_s1 = (rsync_s1 + (1 + (unsigned char)buf[i])) & 0xFFFF;
 	rsync_s2 = (rsync_s2 + rsync_s1) & 0xFFFF;
 	/* Is this the end of a chunk? */
 	if (0 == ((rsync_s1 + rsync_s2) % CHUNK_SIZE)) {
 	    add_chunk(cl, buf, last+1, i+1);
 	    last = i;
 	}
     }
     /* After window is full: */
     for ( ; i<size; i++) {
 	/* Old character out */
 	rsync_s1 = (rsync_s1 - (1 + (unsigned char)buf[i-ROLLING_WINDOW])) & 0xFFFF;
 	rsync_s2 = (rsync_s2 - ROLLING_WINDOW * (1 + (unsigned char)buf[i-ROLLING_WINDOW])) & 0xFFFF;
 	/* New character in */
 	rsync_s1 = (rsync_s1 + (1 + (unsigned char)buf[i])) & 0xFFFF;
 	rsync_s2 = (rsync_s2 + rsync_s1) & 0xFFFF;
 	/* Is this the end of a chunk? */
 	if (0 == ((rsync_s1 + rsync_s2) % CHUNK_SIZE)) {
 	    add_chunk(cl, buf, last+1, i+1);
 	    last = i;
 	}
     }
     /* One last chunk at the end: */
     if (last+1!=size)
 	add_chunk(cl, buf, last+1, size);
     /* done! */
}

/* A treap is a 'heap-ordered tree'.  There are two constraints maintained:
  *   left tree key < this tree key < right tree key
  * and
  *   this heap key < left and right heap keys.
  * We use the sha1 of the chunk (chunk->sha1) as the heap key and the
  * file location (chunk->start) as the tree key.
  * For more info on treaps, see:
  *   C. R. Aragon and R. G. Seidel, "Randomized search trees",
  *   Proc. 30th IEEE FOCS (1989), 540-545.
  * There are many possible binary trees we could build; enforcing the
  * heap constraint ensures that similar files will build similar trees.
  * (The root of the constructed tree will always be the chunk with the
  *  smallest hash key; it's left child will be the chunk with the smallest
  *  hash among those chunk before the root in file order; and so on
  *  recursively.)
  */

/* Assertion helper: check tree and heap constraints. */
static int
treap_valid(struct treap *t) {
     int valid = 1;
     if (!t) return 1;
     if (t->chunk==NULL) return 0;
     if (t->left!=NULL) {
 	/* Tree constraint. */
 	valid = valid && (t->left->chunk->start < t->chunk->start);
 	/* Heap constraint. */
 	valid = valid && (memcmp(t->chunk->sha1, t->left->chunk->sha1,
 				 sizeof(t->chunk->sha1)) < 0);
 	/* 'start' validity */
 	valid = valid && (t->start == t->left->start);
     } else
 	valid = valid && (t->start == t->chunk->start);
     if (t->right!=NULL) {
 	/* Tree constraint. */
 	valid = valid && (t->chunk->start < t->right->chunk->start);
 	/* Heap constraint. */
 	valid = valid && (memcmp(t->chunk->sha1, t->right->chunk->sha1,
 				 sizeof(t->chunk->sha1)) < 0);
 	/* 'end' validity. */
 	valid = valid && (t->end == t->right->end);
     } else
 	valid = valid && (t->end == t->chunk->end);
     return valid;
}

/* Restore heap constraint without disturbing tree ordering. */
/* Only the root of the given treap will violate the heap constraint. */
static struct treap *
treapify(struct treap *t) {
     struct treap *x, *y, *a, *b, *c;
     int left_ok, right_ok, rotate_left;
     assert(treap_valid(t->left));
     assert(treap_valid(t->right));
     left_ok = (t->left == NULL) ||
 	(memcmp(t->chunk->sha1, t->left->chunk->sha1,
 		sizeof(t->chunk->sha1)) < 0);
     right_ok = (t->right == NULL) ||
 	(memcmp(t->chunk->sha1, t->right->chunk->sha1,
 		sizeof(t->chunk->sha1)) < 0);
     if (left_ok && right_ok) { /* well, that's easy */
 	assert(treap_valid(t));
 	return t;
     }
     /* okay, someone needs to rotate */
     rotate_left = (!left_ok) &&
 	(right_ok || /* if neither is okay, then rotate smallest up */
 	 memcmp(t->left->chunk->sha1, t->right->chunk->sha1,
 		sizeof(t->chunk->sha1)) < 0);
     /*   Rotation:
      *     y   -bring left up->  x
      *    / \                   / \
      *   x   c                 a   y
      *  / \                       / \
      * a   b <-bring right up-   b   c
      */
     if (rotate_left) {
 	y = t;  x = y->left;  c = y->right;  a = x->left;  b = x->right;
 	y->left = b;
 	y->right = c;
 	y->start = y->left ? y->left->start : y->chunk->start;
 	y->end = y->right ? y->right->end : y->chunk->end;
 	x->left = a;
 	x->right = treapify(y); // recurse to check heap constraint
 	x->start = x->left ? x->left->start : x->chunk->start;
 	x->end = x->right ? x->right->end : x->chunk->end;
 	assert(treap_valid(x));
 	return x;
     } else {
 	x = t;  a = x->left;  y = x->right;  b = y->left;  c = y->right;
 	x->left = a;
 	x->right = b;
 	x->start = x->left ? x->left->start : x->chunk->start;
 	x->end = x->right ? x->right->end : x->chunk->end;
 	y->right = c;
 	y->left = treapify(x); // recurse to check heap constraint.
 	y->start = y->left ? y->left->start : y->chunk->start;
 	y->end = y->right ? y->right->end : y->chunk->end;
 	assert(treap_valid(y));
 	return y;
     }
}

/* Use list of chunks to build treap bottom-up, calling treapify to
  * restore heap order on the subtree after we add each interior node.
  * This is O(N), where N is the number of chunks. */
static struct treap *
build_treap(struct chunklist *cl, int chunk_st, int chunk_end) {
     struct treap *result;
     /* Some treaps are trivial to build: */
     if (chunk_st >= chunk_end) return NULL;
     /* Claim a chunk in the middle for ourself. */
     int c = (chunk_st + chunk_end)/2;
     result = (struct treap *)malloc(sizeof(*result));
     result->chunk = &(cl->chunk[c]);
     /* Divide and conquer: build well-formed treaps for our kids.*/
     result->left = build_treap(cl, chunk_st, c);
     result->right = build_treap(cl, c+1, chunk_end);
     result->start = result->left ? result->left->start : result->chunk->start;
     result->end = result->right ? result->right->end : result->chunk->end;
     /* Now we need to ensure that the heap constraint is satisfied; that is,
      * result->chunk->sha1 < result->left->chunk->sha1  and
      * result->chunk->sha1 < result->right->chunk->sha1.
      */
     assert(treap_valid(result->left));
     assert(treap_valid(result->right));
     return treapify(result);
}

static void
free_treap(struct treap *t) {
     if (!t) return;
     free_treap(t->left);
     free_treap(t->right);
     free(t);
}

static int
treap_depth(struct treap *t) {
     int l, r;
     if (!t) return 0;
     l = treap_depth(t->left);
     r = treap_depth(t->right);
     return 1 + ((l > r) ? l : r);
}

/* Fill in the treap hashes.  This will be O(N ln M), where N is the
  * file length and M is the number of chunks.  We could actually do
  * this in 2*N time if the subtree hashes were prefix-identical.
  * Since we need to include the chunk length in the hash prefix,
  * we can't reuse the hashing context and we need to pay the extra
  * O(ln M) factor. */
static void
do_treap_hash(struct treap *t, void *data, SHA_CTX *accum, int accum_len) {
     char prefix[200];
     SHA_CTX *cp;
     int i;

     assert(treap_valid(t));
     if (!t) return;

     /* Start a new treap context. */
     cp = &(accum[accum_len++]);
     SHA1_Init(cp);
     /* Sticking the size in the prefix makes me unhappy. =( */
     SHA1_Update(cp, prefix, 1+sprintf(prefix, "blob %lu", t->end - t->start));
     /* Recurse on the left. */
     do_treap_hash(t->left, data, accum, accum_len);
     /* Add in our chunk. */
     for (i=0; i<accum_len; i++)
 	SHA1_Update(accum + i, data + t->chunk->start,
 		    t->chunk->end - t->chunk->start);
     /* Recurse on the right. */
     do_treap_hash(t->right, data, accum, accum_len);
     /* Finalize and write it to t->sha1. */
     SHA1_Final(t->sha1, cp);
     /* Done! */
}
/* Helper method. */
static void
compute_treap_hashes(struct treap *t, void *data) {
     /* Allocate space for each level of the treap to have its own context. */
     SHA_CTX contexts[treap_depth(t)];
     do_treap_hash(t, data, contexts, 0);
}
/* Yuck. */
static const char *
compute_null_treap_hash() {
     static const char fixed[] = { "blob 0" };
     static char sha1[20], *cp=NULL;
     SHA_CTX c;
     if (cp) return cp;
     SHA1_Init(&c);
     SHA1_Update(&c, fixed, sizeof(fixed));
     SHA1_Final(sha1, &c);
     cp = sha1;
     return cp;
}


/* Now that we've broken it down into treap-structured pieces, let's write
  * them to the object store. */

/* Write a single treap piece to the object store.  Note that 't' may be
  * NULL for the special case of a zero-byte file.  Writes the hash of
  * this piece back to 'sha1', which must be non-NULL. Returns 0 on success.*/
static int
write_one(struct treap *t, char *buf) {
/* two hundred bytes is two 20-byte SHA1 hashes, two presence bytes,
  * six bytes of type, one null, and plus 10^151 file length. (Conservative.) */
#define MAX_METADATA_LEN 200
     z_stream stream;
     ch_size_t max_out_bytes;
     ch_size_t chunk_size = t ? (t->chunk->end - t->chunk->start) : 0;
     ch_size_t content_size, metadata_size;
     char metadata[MAX_METADATA_LEN];
     void *out;

     /*
      * Metadata: Type, ASCII size, null byte, then left & right hashes.
      */
     content_size = chunk_size+2; /* prefix/suffix delimiters */
     if (t && t->left) content_size += sizeof(t->left->sha1);
     if (t && t->right) content_size += sizeof(t->right->sha1);
     metadata_size =  1+sprintf(metadata, "chunk %lu", content_size);
     if (t && t->left) { /* left hash */
 	metadata[metadata_size++] = 1;
 	memcpy(metadata + metadata_size, t->left->sha1, sizeof(t->left->sha1));
 	metadata_size += sizeof(t->left->sha1);
     } else
 	metadata[metadata_size++] = 0; /* no prefix chunk */
     if (t && t->right) { /* right hash */
 	metadata[metadata_size++] = 1;
 	memcpy(metadata + metadata_size,t->right->sha1,sizeof(t->right->sha1));
 	metadata_size += sizeof(t->right->sha1);
     } else
 	metadata[metadata_size++] = 0; /* no suffix chunk */

     memset(&stream, 0, sizeof(stream));
     deflateInit(&stream, Z_BEST_COMPRESSION);
     max_out_bytes = deflateBound(&stream, chunk_size+metadata_size);
     out = malloc(max_out_bytes);
     stream.next_out = out;
     stream.avail_out = max_out_bytes;

     /* Compress metadata. */
     stream.next_in = metadata;
     stream.avail_in = metadata_size;
     while (deflate(&stream, 0) == Z_OK)
 	    /* nothing */;

     /*
      * Chunk content.
      */
     stream.next_in = buf + ( t ? t->chunk->start : 0);
     stream.avail_in = chunk_size; /* possibly zero */
     while (deflate(&stream, Z_FINISH) == Z_OK)
 	/* nothing */;

     deflateEnd(&stream);

     return write_sha1_buffer(t ? (const char*) t->sha1 :
 			     compute_null_treap_hash(),
 			     out, stream.total_out);
}

/* Write all treap nodes to disk. */
static int
write_treap(struct treap *t, char *buf, char *sha1) {
     /* First write children (which initializes their SHA1 info). */
     if (t && t->left)
 	if (write_treap(t->left, buf, NULL) < 0)
 	    return -1; /* failure. */
     if (t && t->right)
 	if (write_treap(t->right, buf, NULL) < 0)
 	    return -1; /* failure. */
     /* Now write us.  Note t may == NULL for a zero-byte file. */
     if (write_one(t, buf) < 0)
 	return -1; /* failure. */
     /* Write back sha1, if wanted. */
     if (sha1)
 	memcpy(sha1, t ? (const char*)t->sha1 : compute_null_treap_hash(),
 	       sizeof(t->sha1));
     return 0;
}

/* EXPORTED FUNCTION: write the file open on file descriptor 'fd'
  * and described by 'ce' and 'st' to the object store.   Return
  * 0 on success, -1 on failure. */
/* This does the same thing as 'index_fd' in Linus' update-cache.c */
int
chunk_index_fd(struct cache_entry *ce, int fd, struct stat *st) {
     struct chunklist *cl;
     struct treap *t;
     char *in;

     /* We expect there to be 'file length / CHUNK_SIZE' chunks.  Over-estimate
      * a little, and do the initial chunk list allocation. */
     cl = create_chunklist(1 + ((3 * st->st_size) / (2 * CHUNK_SIZE)));
     /* Split the file into chunks. */
     in = "";
     if (st->st_size)
 	in = mmap(NULL, st->st_size, PROT_READ, MAP_PRIVATE, fd, 0);
     close(fd);
     if (in==MAP_FAILED) return -1;

     chunkify(cl, in, st->st_size);
     /* Build the treap. */
     t = build_treap(cl, 0, cl->num_items);
     assert(treap_valid(t));
     /* Compute all the hashes. */
     compute_treap_hashes(t, in);
     /* Now write all the pieces, updating SHA1 for this file in the process. */
     if (write_treap(t, in, ce->sha1) < 0)
 	return -1;
     /* Free everything; we're done. */
     free_treap(t);
     free_chunklist(cl);
     if (st->st_size)
 	munmap(in, st->st_size);
     return 0; /* success! */
}

/*** Functions to read a chunked file into a contiguous buffer. ***/

struct read_chunk {
     void *data, *chunk_data;
     ch_size_t chunk_size, total_size;
     struct read_chunk *left, *right;
};
static struct read_chunk *
read_chunk2(const unsigned char *sha1, void *data, ch_size_t size);

static struct read_chunk *
read_chunk(const unsigned char *sha1) {
     void *data;
     ch_size_t size;
     char type[10];
     data = read_sha1_file(sha1, type, &size);
     assert(strcmp(type, "chunk")==0);
     return read_chunk2(sha1, data, size); 
}
static struct read_chunk *
read_chunk2(const unsigned char *sha1, void *data, ch_size_t size) {
     unsigned char *cp;
     struct read_chunk *result = malloc(sizeof(*result));
     cp = result->data = data;
     printf("CHUNK %s (%lu bytes)\n", sha1_to_hex(sha1), size);
     /* Parse the chunk data. */
     result->left = result->right = NULL;
     if (*cp++) {
 	result->left = read_chunk(cp); cp+=20;
     }
     if (*cp++) {
 	result->right = read_chunk(cp); cp+=20;
     }
     result->chunk_data = cp;
     result->chunk_size = size - (result->chunk_data - result->data);
     result->total_size = result->chunk_size +
 	(result->left ? result->left->total_size : 0) +
 	(result->right ? result->right->total_size : 0);
     return result;
}
static void
copy_read_chunk(void *dest, struct read_chunk *rc) {
     if (rc->left) {
 	copy_read_chunk(dest, rc->left);
 	dest += rc->left->total_size;
     }
     memcpy(dest, rc->chunk_data, rc->chunk_size);
     if (rc->right)
 	copy_read_chunk(dest + rc->chunk_size, rc->right);
}
static void
free_read_chunk(struct read_chunk *rc) {
     if (rc->left) free_read_chunk(rc->left);
     if (rc->right) free_read_chunk(rc->right);
     free(rc->data);
     free(rc);
}

/* This does the same thing as 'read_sha1_file' in Linus' read_cache.c,
  * except that it knows about the 'chunk' encoding and will transparently
  * stitch together the appropriate prefix and suffix chunks and pass it
  * off as a 'blob'. */
void *
chunk_read_sha1_file(const unsigned char *sha1, char *type, unsigned long *size) {
     struct read_chunk *rc;
     void *result = read_sha1_file(sha1, type, size);
     if (strcmp(type, "chunk")!=0) return result;
     /* This is a 'chunk' object; get the rest of the pieces. */
     rc = read_chunk2(sha1, result, *size);
     /* Now concatenate them together. */
     strcpy(type, "blob");
     *size = rc->total_size;
     result = malloc(*size);
     copy_read_chunk(result, rc);
     /* done! */
     free_read_chunk(rc);
     return result;
}

#if 0
/* Exercise this code. */
int main(int argc, char **argv) {
     struct cache_entry ce;
     struct stat st;
     char *buf, type[10];
     unsigned long size;
     int fd;
     fd = open(argv[1], O_RDONLY);
     if (fd < 0) exit(1);
     if (fstat(fd, &st) < 0) exit(1);
     if (chunk_index_fd(&ce, fd, &st) < 0) exit(1);
     printf("Wrote file %s.\n", sha1_to_hex(ce.sha1));
     /* seemed to work! */
     buf = chunk_read_sha1_file(ce.sha1, type, &size);
     if (!buf) exit(1);
     printf("Read file %s, of type %s (%lu bytes):\n",
 	   sha1_to_hex(ce.sha1), type, size);
     fwrite(buf, size, 1, stdout);
     /* done! */
     return 0;
}
#endif
-
To unsubscribe from this list: send the line "unsubscribe git" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html



From news@gmane.org Tue Mar 04 03:33:20 2003
From: David Greaves <david@dgreaves.com>
Subject: Re: [PATCH] Some documentation...
Date: Wed, 20 Apr 2005 18:35:13 +0100
Lines: 48
Message-ID: <426692D1.20304@dgreaves.com>
References: <42668C8D.3000209@dgreaves.com> <Pine.LNX.4.61.0504201321380.2630@cag.csail.mit.edu>
Mime-Version: 1.0
Content-Type: text/plain; charset=US-ASCII; format=flowed
Content-Transfer-Encoding: 7bit
Cc: git@vger.kernel.org
X-From: git-owner@vger.kernel.org Wed Apr 20 19:33:54 2005
Return-path: <git-owner@vger.kernel.org>
Received: from vger.kernel.org ([12.107.209.244])
	by ciao.gmane.org with esmtp (Exim 4.43)
	id 1DOJ42-00065Y-1q
	for gcvg-git@gmane.org; Wed, 20 Apr 2005 19:32:38 +0200
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S261688AbVDTRgO (ORCPT <rfc822;gcvg-git@m.gmane.org>);
	Wed, 20 Apr 2005 13:36:14 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S261735AbVDTRfl
	(ORCPT <rfc822;git-outgoing>); Wed, 20 Apr 2005 13:35:41 -0400
Received: from s2.ukfsn.org ([217.158.120.143]:31709 "EHLO mail.ukfsn.org")
	by vger.kernel.org with ESMTP id S261689AbVDTRfP (ORCPT
	<rfc822;git@vger.kernel.org>); Wed, 20 Apr 2005 13:35:15 -0400
Received: from localhost (lucy.ukfsn.org [127.0.0.1])
	by mail.ukfsn.org (Postfix) with ESMTP
	id 04546E6D5D; Wed, 20 Apr 2005 18:33:30 +0100 (BST)
Received: from mail.ukfsn.org ([127.0.0.1])
 by localhost (lucy.ukfsn.org [127.0.0.1]) (amavisd-new, port 10024)
 with ESMTP id 16158-14; Wed, 20 Apr 2005 18:33:29 +0100 (BST)
Received: from oak.dgreaves.com (modem-1977.baboon.dialup.pol.co.uk [81.78.23.185])
	by mail.ukfsn.org (Postfix) with ESMTP
	id 42E07E6A88; Wed, 20 Apr 2005 18:33:29 +0100 (BST)
Received: from ash.dgreaves.com ([10.0.0.90])
	by oak.dgreaves.com with esmtp (Exim 4.20)
	id 1DOJ6X-0000fa-Cu; Wed, 20 Apr 2005 18:35:13 +0100
User-Agent: Debian Thunderbird 1.0 (X11/20050116)
X-Accept-Language: en-us, en
To: "C. Scott Ananian" <cscott@cscott.net>
In-Reply-To: <Pine.LNX.4.61.0504201321380.2630@cag.csail.mit.edu>
X-Enigmail-Version: 0.90.0.0
X-Enigmail-Supports: pgp-inline, pgp-mime
Sender: git-owner@vger.kernel.org
Precedence: bulk
X-Mailing-List: git@vger.kernel.org
Status: RO

C. Scott Ananian wrote:
> On Wed, 20 Apr 2005, David Greaves wrote:
> 
>> In doing this I noticed a couple of points:
>> * update-cache won't accept ./file or fred/./file
> 
> 
> The comment in update-cache.c reads:
> /*
>  * We fundamentally don't like some paths: we don't want
>  * dot or dot-dot anywhere, and in fact, we don't even want
>  * any other dot-files (.git or anything else). They
>  * are hidden, for chist sake.
>  *
>  * Also, we don't want double slashes or slashes at the
>  * end that can make pathnames ambiguous.
>  */
> 
> It could be argued that './' is a special case... but at the moment this 
> is definitely a designed 'feature' not a 'bug'.

Indeed - I've been reading the code to document it as correctly as possible.

But I actually found this by running:

   find . -type f | xargs git add

for a new project - so I'd class it as user unfriendly...
Yes, I know how to get round it :)

I have ensured that my next perl version of gitadd.pl (that I submitted 
to Petr) doesn't allow these files to be added - and it could even 
cleanse leading ./ and any /./ constructs.

So maybe it's left as documented behaviour and higher level tools must 
manage the data they feed to it...

I hope it's useful to raise these niggles now before changing them is 
too hard.

David

-- 
-
To unsubscribe from this list: send the line "unsubscribe git" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html



From news@gmane.org Tue Mar 04 03:33:20 2003
From: Linus Torvalds <torvalds@osdl.org>
Subject: Re: [PATCH] write-tree performance problems
Date: Wed, 20 Apr 2005 10:52:17 -0700 (PDT)
Lines: 74
Message-ID: <Pine.LNX.4.58.0504201040400.6467@ppc970.osdl.org>
References: <200504191250.10286.mason@suse.com> <200504201237.38374.mason@suse.com>
 <Pine.LNX.4.58.0504200957030.6467@ppc970.osdl.org> <200504201323.05447.mason@suse.com>
Mime-Version: 1.0
Content-Type: TEXT/PLAIN; charset=US-ASCII
Cc: git@vger.kernel.org
X-From: git-owner@vger.kernel.org Wed Apr 20 19:47:08 2005
Return-path: <git-owner@vger.kernel.org>
Received: from vger.kernel.org ([12.107.209.244])
	by ciao.gmane.org with esmtp (Exim 4.43)
	id 1DOJHP-0008MC-Q6
	for gcvg-git@gmane.org; Wed, 20 Apr 2005 19:46:28 +0200
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S261702AbVDTRuj (ORCPT <rfc822;gcvg-git@m.gmane.org>);
	Wed, 20 Apr 2005 13:50:39 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S261773AbVDTRuj
	(ORCPT <rfc822;git-outgoing>); Wed, 20 Apr 2005 13:50:39 -0400
Received: from fire.osdl.org ([65.172.181.4]:34002 "EHLO smtp.osdl.org")
	by vger.kernel.org with ESMTP id S261702AbVDTRuY (ORCPT
	<rfc822;git@vger.kernel.org>); Wed, 20 Apr 2005 13:50:24 -0400
Received: from shell0.pdx.osdl.net (fw.osdl.org [65.172.181.6])
	by smtp.osdl.org (8.12.8/8.12.8) with ESMTP id j3KHoKs4017092
	(version=TLSv1/SSLv3 cipher=EDH-RSA-DES-CBC3-SHA bits=168 verify=NO);
	Wed, 20 Apr 2005 10:50:20 -0700
Received: from localhost (shell0.pdx.osdl.net [10.9.0.31])
	by shell0.pdx.osdl.net (8.13.1/8.11.6) with ESMTP id j3KHoJBo017696;
	Wed, 20 Apr 2005 10:50:19 -0700
To: Chris Mason <mason@suse.com>
In-Reply-To: <200504201323.05447.mason@suse.com>
X-Spam-Status: No, hits=0 required=5 tests=
X-Spam-Checker-Version: SpamAssassin 2.63-osdl_revision__1.35__
X-MIMEDefang-Filter: osdl$Revision: 1.109 $
X-Scanned-By: MIMEDefang 2.36
Sender: git-owner@vger.kernel.org
Precedence: bulk
X-Mailing-List: git@vger.kernel.org
Status: RO



On Wed, 20 Apr 2005, Chris Mason wrote:
> 
> The patch below with your current tree brings my 100 patch test down to 22 
> seconds again.

If you ever have a cache_entry bigger than 16384, your code will write 
things out in the wrong order (write the new cache without flushing the 
old buffer).

You also don't free the buffer.

Finally, if you really want to go fast, you should really try to make your
writes powers-of-two, ie fill up the buffer entirely rather than saying
"if I were to overflow, flush it now". It doesn't matter that much for
some filesystems (especially local and append-only like the patterns are
here), but it can definitely matter for the stupid ones.

But yeah, we could obviously chunk things out properly. You might want to 
just use stdio and "fwrite()", though, which does all of that for you, and 
hopefully does it right.

(I'm not a big fan of stdio for something like this, so if you want to 
create a little helper function that just does the chunking, go wild. 
Something like

	#define BUFSIZ 8192
	static char buffer[BUFSIZ];
	static unsigned long buflen;

	int ce_write(int fd, void *data, unsigned int len)
	{
		while (len) {
			unsigned int buffered = buflen;
			unsigned int partial = BUFSIZ - buflen;
			if (partial > len)
				partial = len;
			memcpy(buffer + buflen, data, partial);
			buffered += partial;
			if (buffered == BUFSIZ) {
				if (write(fd, buffer, BUFSIZ) != BUFSIZ)
					die("unable to write");
				buffered = 0;
			}
			buflen = buffered;
			len -= partial;
			data += partial;
		}
	}

	int ce_flush(int fd)
	{
		unsigned int left = buflen;
		if (left) {
			buflen = 0;
			if (write(fd, buffer, left) != left)
				die("unable to write");
		}
	}

which should be ok, and cheesily avoids the allocation overhread issues by
just having a nice static buffer.

"If you want to go fast, do it right".

Untested, as usual.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe git" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html



From news@gmane.org Tue Mar 04 03:33:20 2003
From: Matt Mackall <mpm@selenic.com>
Subject: distributed merge prototype
Date: Wed, 20 Apr 2005 10:50:42 -0700
Lines: 37
Message-ID: <20050420175042.GH21897@waste.org>
Mime-Version: 1.0
Content-Type: text/plain; charset=us-ascii
X-From: git-owner@vger.kernel.org Wed Apr 20 19:47:41 2005
Return-path: <git-owner@vger.kernel.org>
Received: from vger.kernel.org ([12.107.209.244])
	by ciao.gmane.org with esmtp (Exim 4.43)
	id 1DOJHf-0008PV-Jz
	for gcvg-git@gmane.org; Wed, 20 Apr 2005 19:46:43 +0200
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S261773AbVDTRu4 (ORCPT <rfc822;gcvg-git@m.gmane.org>);
	Wed, 20 Apr 2005 13:50:56 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S261769AbVDTRu4
	(ORCPT <rfc822;git-outgoing>); Wed, 20 Apr 2005 13:50:56 -0400
Received: from waste.org ([216.27.176.166]:55982 "EHLO waste.org")
	by vger.kernel.org with ESMTP id S261773AbVDTRup (ORCPT
	<rfc822;git@vger.kernel.org>); Wed, 20 Apr 2005 13:50:45 -0400
Received: from waste.org (localhost [127.0.0.1])
	by waste.org (8.13.4/8.13.4/Debian-1) with ESMTP id j3KHogtV014060
	(version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-SHA bits=256 verify=NOT)
	for <git@vger.kernel.org>; Wed, 20 Apr 2005 12:50:42 -0500
Received: (from oxymoron@localhost)
	by waste.org (8.13.4/8.13.4/Submit) id j3KHogPp014057
	for git@vger.kernel.org; Wed, 20 Apr 2005 12:50:42 -0500
To: git@vger.kernel.org
Content-Disposition: inline
User-Agent: Mutt/1.5.6+20040907i
X-Virus-Scanned: by amavisd-new
Sender: git-owner@vger.kernel.org
Precedence: bulk
X-Mailing-List: git@vger.kernel.org
Status: RO

I've hacked together a prototype SCM that I think you folks might be
interested in. The announcement is here:

 http://selenic.com/mercurial/announce.txt

It's at a very early stage right now and is likely to break if you
look at it wrong, but I have sucessfully managed to check in kernel
trees, do a local clone/branch, make changes in both trees, and then
do a pull/sync which called up tkdiff where appropriate.

I mention it here because I've got a fairly simple implementation of
distributed merge ala Monotone or BK with the necessary graph smarts.
It also should perform decently - I've paid a lot of attention to the
scalability of the core algorithms. The core of the merge code is less
than 100 lines so even people who aren't familiar with Python may be
able to wrap their head around it and leverage it for git.

I'd also like to encourage more attention to back-end storage.
Mercurial can check in all 495 versions of linux/Makefile from bkcvs
to compressed delta store in about 5 seconds on my laptop and the
result is about 80K (bkcvs takes 254K). Adding and retrieving
revisions is O(1).

The same directory individually compressed by gzip (ie what git does)
takes a comparable amount of time and 5.1M of disk space. This is
admittedly a worst case for git as most of the deltas are small, but I
needed a test file with lots of revisions.

Now back to our regularly scheduled programming..

-- 
Mathematics is the supreme nostalgia of our time.
-
To unsubscribe from this list: send the line "unsubscribe git" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html



From news@gmane.org Tue Mar 04 03:33:20 2003
From: "David S. Miller" <davem@davemloft.net>
Subject: Re: [PATCH] write-tree performance problems
Date: Wed, 20 Apr 2005 11:07:20 -0700
Lines: 18
Message-ID: <20050420110720.0ff887b4.davem@davemloft.net>
References: <200504191250.10286.mason@suse.com>
	<200504201122.35448.mason@suse.com>
	<Pine.LNX.4.58.0504200833580.6467@ppc970.osdl.org>
	<200504201237.38374.mason@suse.com>
	<Pine.LNX.4.58.0504200957030.6467@ppc970.osdl.org>
Mime-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Cc: mason@suse.com, git@vger.kernel.org
X-From: git-owner@vger.kernel.org Wed Apr 20 20:10:13 2005
Return-path: <git-owner@vger.kernel.org>
Received: from vger.kernel.org ([12.107.209.244])
	by ciao.gmane.org with esmtp (Exim 4.43)
	id 1DOJdw-0003gY-K5
	for gcvg-git@gmane.org; Wed, 20 Apr 2005 20:09:45 +0200
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S261709AbVDTSOA (ORCPT <rfc822;gcvg-git@m.gmane.org>);
	Wed, 20 Apr 2005 14:14:00 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S261777AbVDTSOA
	(ORCPT <rfc822;git-outgoing>); Wed, 20 Apr 2005 14:14:00 -0400
Received: from dsl027-180-174.sfo1.dsl.speakeasy.net ([216.27.180.174]:30367
	"EHLO cheetah.davemloft.net") by vger.kernel.org with ESMTP
	id S261709AbVDTSN7 (ORCPT <rfc822;git@vger.kernel.org>);
	Wed, 20 Apr 2005 14:13:59 -0400
Received: from localhost
	([127.0.0.1] helo=cheetah.davemloft.net ident=davem)
	by cheetah.davemloft.net with smtp (Exim 3.36 #1 (Debian))
	id 1DOJbc-0000SD-00; Wed, 20 Apr 2005 11:07:20 -0700
To: Linus Torvalds <torvalds@osdl.org>
In-Reply-To: <Pine.LNX.4.58.0504200957030.6467@ppc970.osdl.org>
X-Mailer: Sylpheed version 1.0.4 (GTK+ 1.2.10; sparc-unknown-linux-gnu)
X-Face: "_;p5u5aPsO,_Vsx"^v-pEq09'CU4&Dc1$fQExov$62l60cgCc%FnIwD=.UF^a>?5'9Kn[;433QFVV9M..2eN.@4ZWPGbdi<=?[:T>y?SD(R*-3It"Vj:)"dP
Sender: git-owner@vger.kernel.org
Precedence: bulk
X-Mailing-List: git@vger.kernel.org
Status: RO

On Wed, 20 Apr 2005 10:06:15 -0700 (PDT)
Linus Torvalds <torvalds@osdl.org> wrote:

> I bet your SHA1 implementation is done with hand-optimized and scheduled
> x86 MMX code or something, while my poor G5 is probably using some slow
> generic routine. As a result, it only improved by 33% for me since the
> compression was just part of the picture, but with your cheap SHA1 the
> compression costs really dominated, and so it's almost four times faster
> for you.

The openssl tree has a i586 optimized SHA1 implementation.
A quick scan of the 0.9.7e tree I happen to have lying around
shows there aren't optimized for other cpus in there, just i586.
-
To unsubscribe from this list: send the line "unsubscribe git" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html



From news@gmane.org Tue Mar 04 03:33:20 2003
From: David Meybohm <dmeybohmlkml@bellsouth.net>
Subject: Re: SHA1 hash safety
Date: Wed, 20 Apr 2005 14:56:53 -0400
Lines: 21
Message-ID: <20050420185653.GA3076@localhost>
References: <Pine.LNX.4.62.0504160519330.21837@qynat.qvtvafvgr.pbz> <20050416123155.GA19908@elte.hu> <Pine.LNX.4.62.0504160542190.21837@qynat.qvtvafvgr.pbz> <4261132A.3090907@khandalf.com> <Pine.LNX.4.61.0504161040310.29343@cag.csail.mit.edu> <4261852B.6090507@khandalf.com> <20050418074323.GA29765@hexapodia.org> <20050419223027.GA26100@localhost> <Pine.LNX.4.61.0504191848300.29929@cag.csail.mit.edu>
Mime-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Cc: Andy Isaacson <adi@hexapodia.org>, omb@bluewin.ch,
	git@vger.kernel.org
X-From: git-owner@vger.kernel.org Wed Apr 20 20:53:27 2005
Return-path: <git-owner@vger.kernel.org>
Received: from vger.kernel.org ([12.107.209.244])
	by ciao.gmane.org with esmtp (Exim 4.43)
	id 1DOKJc-0001d3-N5
	for gcvg-git@gmane.org; Wed, 20 Apr 2005 20:52:49 +0200
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S261471AbVDTS5B (ORCPT <rfc822;gcvg-git@m.gmane.org>);
	Wed, 20 Apr 2005 14:57:01 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S261683AbVDTS5B
	(ORCPT <rfc822;git-outgoing>); Wed, 20 Apr 2005 14:57:01 -0400
Received: from imf17aec.mail.bellsouth.net ([205.152.59.65]:29570 "EHLO
	imf17aec.mail.bellsouth.net") by vger.kernel.org with ESMTP
	id S261471AbVDTS44 (ORCPT <rfc822;git@vger.kernel.org>);
	Wed, 20 Apr 2005 14:56:56 -0400
Received: from localhost ([65.10.203.194]) by imf17aec.mail.bellsouth.net
          (InterMail vM.5.01.06.11 201-253-122-130-111-20040605) with ESMTP
          id <20050420185656.LEUH2434.imf17aec.mail.bellsouth.net@localhost>;
          Wed, 20 Apr 2005 14:56:56 -0400
To: "C. Scott Ananian" <cscott@cscott.net>
Content-Disposition: inline
In-Reply-To: <Pine.LNX.4.61.0504191848300.29929@cag.csail.mit.edu>
User-Agent: Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.5) Gecko/20030927
Sender: git-owner@vger.kernel.org
Precedence: bulk
X-Mailing-List: git@vger.kernel.org
Status: RO

On Tue, Apr 19, 2005 at 06:48:57PM -0400, C. Scott Ananian wrote:
> On Tue, 19 Apr 2005, David Meybohm wrote:
> 
> >But doesn't this require assuming the distribution of MD5 is uniform,
> >and don't the papers finding collisions in less show it's not? So, your
> >birthday-argument for calculating the probability wouldn't apply, because
> >it rests on the assumption MD5 is uniform, and it isn't.
> 
> No, the collision papers don't show this at all.

I didn't mean they showed it directly. I meant by finding collisions in
MD5 quickly, MD5 would have to have some non-uniformity. But that's
nevertheless wrong because uniformness and collision finding ability
aren't related. Sorry to have wasted everyone's time.

Dave
-
To unsubscribe from this list: send the line "unsubscribe git" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html



From news@gmane.org Tue Mar 04 03:33:20 2003
From: Chris Mason <mason@suse.com>
Subject: Re: [PATCH] write-tree performance problems
Date: Wed, 20 Apr 2005 15:04:58 -0400
Lines: 104
Message-ID: <200504201504.59541.mason@suse.com>
References: <200504191250.10286.mason@suse.com> <200504201323.05447.mason@suse.com> <Pine.LNX.4.58.0504201040400.6467@ppc970.osdl.org>
Mime-Version: 1.0
Content-Type: Multipart/Mixed;
  boundary="Boundary-00=_bfqZCE4E/ZEDLge"
Cc: git@vger.kernel.org
X-From: git-owner@vger.kernel.org Wed Apr 20 21:02:36 2005
Return-path: <git-owner@vger.kernel.org>
Received: from vger.kernel.org ([12.107.209.244])
	by ciao.gmane.org with esmtp (Exim 4.43)
	id 1DOKRr-0002ve-25
	for gcvg-git@gmane.org; Wed, 20 Apr 2005 21:01:19 +0200
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S261530AbVDTTFX (ORCPT <rfc822;gcvg-git@m.gmane.org>);
	Wed, 20 Apr 2005 15:05:23 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S261687AbVDTTFX
	(ORCPT <rfc822;git-outgoing>); Wed, 20 Apr 2005 15:05:23 -0400
Received: from mail.suse.de ([195.135.220.2]:43659 "EHLO mx1.suse.de")
	by vger.kernel.org with ESMTP id S261530AbVDTTFH (ORCPT
	<rfc822;git@vger.kernel.org>); Wed, 20 Apr 2005 15:05:07 -0400
Received: from extimap.suse.de (extimap.suse.de [195.135.220.6])
	(using TLSv1 with cipher EDH-RSA-DES-CBC3-SHA (168/168 bits))
	(No client certificate requested)
	by mx1.suse.de (Postfix) with ESMTP id 25C49160A3B1;
	Wed, 20 Apr 2005 21:05:06 +0200 (CEST)
To: Linus Torvalds <torvalds@osdl.org>
User-Agent: KMail/1.8
In-Reply-To: <Pine.LNX.4.58.0504201040400.6467@ppc970.osdl.org>
Sender: git-owner@vger.kernel.org
Precedence: bulk
X-Mailing-List: git@vger.kernel.org
Status: RO

--Boundary-00=_bfqZCE4E/ZEDLge
Content-Type: text/plain;
  charset="iso-8859-1"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

On Wednesday 20 April 2005 13:52, Linus Torvalds wrote:
> On Wed, 20 Apr 2005, Chris Mason wrote:
> > The patch below with your current tree brings my 100 patch test down to
> > 22 seconds again.
>
> If you ever have a cache_entry bigger than 16384, your code will write
> things out in the wrong order (write the new cache without flushing the
> old buffer).

Whoops

> Finally, if you really want to go fast, you should really try to make your
> writes powers-of-two, ie fill up the buffer entirely rather than saying
> "if I were to overflow, flush it now". It doesn't matter that much for
> some filesystems (especially local and append-only like the patterns are
> here), but it can definitely matter for the stupid ones.

Well, the difference there should be pretty hard to see with any benchmark.
But I was being lazy...new patch attached.  This one gets the same perf 
numbers, if this is still wrong then I really need some more coffee.

-chris


--Boundary-00=_bfqZCE4E/ZEDLge
Content-Type: text/x-diff;
  charset="iso-8859-1";
  name="read-cache-fast.diff"
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment;
	filename="read-cache-fast.diff"

--- linus.back/read-cache.c	2005-04-20 10:14:23.268310000 -0400
+++ linus/read-cache.c	2005-04-20 14:54:28.554518320 -0400
@@ -232,11 +232,13 @@
 	SHA_CTX c;
 	struct cache_header hdr;
 	int i;
+	#define BUFLEN 16384
+	static char buf[BUFLEN];
+	int len = 0;
 
 	hdr.hdr_signature = htonl(CACHE_SIGNATURE);
 	hdr.hdr_version = htonl(1);
 	hdr.hdr_entries = htonl(entries);
-
 	SHA1_Init(&c);
 	SHA1_Update(&c, &hdr, offsetof(struct cache_header, sha1));
 	for (i = 0; i < entries; i++) {
@@ -246,13 +248,37 @@
 	}
 	SHA1_Final(hdr.sha1, &c);
 
-	if (write(newfd, &hdr, sizeof(hdr)) != sizeof(hdr))
-		return -1;
-
+	/* hdr is small right now, but just
+	 * in case someone changes that...
+	 */
+	if (sizeof(hdr) < BUFLEN) {
+		memcpy(buf, &hdr, sizeof(hdr));
+		len += sizeof(hdr);
+	} else {
+		if (write(newfd, &hdr, sizeof(hdr)) != sizeof(hdr))
+			return -1;
+	}
 	for (i = 0; i < entries; i++) {
 		struct cache_entry *ce = cache[i];
 		int size = ce_size(ce);
-		if (write(newfd, ce, size) != size)
+		char *p = (char *)ce;
+		while(size > 0) {
+			int count = size;
+			if (count > BUFLEN - len)
+				count = BUFLEN - len;
+			memcpy(buf + len, p, count);
+			size -= count;
+			len += count;
+			p += count;
+			if (len == BUFLEN) {
+				if (write(newfd, buf, len) != len)
+					return -1;
+				len = 0;
+			}
+		}
+	}
+	if (len) {
+		if (write(newfd, buf, len) != len)
 			return -1;
 	}
 	return 0;

--Boundary-00=_bfqZCE4E/ZEDLge--
-
To unsubscribe from this list: send the line "unsubscribe git" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html



From news@gmane.org Tue Mar 04 03:33:20 2003
From: Linus Torvalds <torvalds@osdl.org>
Subject: Re: [PATCH] write-tree performance problems
Date: Wed, 20 Apr 2005 12:19:53 -0700 (PDT)
Lines: 20
Message-ID: <Pine.LNX.4.58.0504201218360.6467@ppc970.osdl.org>
References: <200504191250.10286.mason@suse.com> <200504201323.05447.mason@suse.com>
 <Pine.LNX.4.58.0504201040400.6467@ppc970.osdl.org> <200504201504.59541.mason@suse.com>
Mime-Version: 1.0
Content-Type: TEXT/PLAIN; charset=US-ASCII
Cc: git@vger.kernel.org
X-From: git-owner@vger.kernel.org Wed Apr 20 21:15:31 2005
Return-path: <git-owner@vger.kernel.org>
Received: from vger.kernel.org ([12.107.209.244])
	by ciao.gmane.org with esmtp (Exim 4.43)
	id 1DOKeN-0004r2-Tp
	for gcvg-git@gmane.org; Wed, 20 Apr 2005 21:14:16 +0200
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S261743AbVDTTSL (ORCPT <rfc822;gcvg-git@m.gmane.org>);
	Wed, 20 Apr 2005 15:18:11 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S261692AbVDTTSK
	(ORCPT <rfc822;git-outgoing>); Wed, 20 Apr 2005 15:18:10 -0400
Received: from fire.osdl.org ([65.172.181.4]:48001 "EHLO smtp.osdl.org")
	by vger.kernel.org with ESMTP id S261743AbVDTTSB (ORCPT
	<rfc822;git@vger.kernel.org>); Wed, 20 Apr 2005 15:18:01 -0400
Received: from shell0.pdx.osdl.net (fw.osdl.org [65.172.181.6])
	by smtp.osdl.org (8.12.8/8.12.8) with ESMTP id j3KJHts4024775
	(version=TLSv1/SSLv3 cipher=EDH-RSA-DES-CBC3-SHA bits=168 verify=NO);
	Wed, 20 Apr 2005 12:17:55 -0700
Received: from localhost (shell0.pdx.osdl.net [10.9.0.31])
	by shell0.pdx.osdl.net (8.13.1/8.11.6) with ESMTP id j3KJHs5t022775;
	Wed, 20 Apr 2005 12:17:55 -0700
To: Chris Mason <mason@suse.com>
In-Reply-To: <200504201504.59541.mason@suse.com>
X-Spam-Status: No, hits=0 required=5 tests=
X-Spam-Checker-Version: SpamAssassin 2.63-osdl_revision__1.35__
X-MIMEDefang-Filter: osdl$Revision: 1.109 $
X-Scanned-By: MIMEDefang 2.36
Sender: git-owner@vger.kernel.org
Precedence: bulk
X-Mailing-List: git@vger.kernel.org
Status: RO



On Wed, 20 Apr 2005, Chris Mason wrote:
> 
> Well, the difference there should be pretty hard to see with any benchmark.
> But I was being lazy...new patch attached.  This one gets the same perf 
> numbers, if this is still wrong then I really need some more coffee.

I did my preferred version. Makes a big difference here too.

It would be nicer for the cache to make the index file "header" be a 
"footer", and write it out last - that way we'd be able to do the SHA1 as 
we write rather than doing a two-pass thing. That's for another time.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe git" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html



From news@gmane.org Tue Mar 04 03:33:20 2003
From: Linus Torvalds <torvalds@osdl.org>
Subject: Re: [PATCH] write-tree performance problems
Date: Wed, 20 Apr 2005 12:47:59 -0700 (PDT)
Lines: 45
Message-ID: <Pine.LNX.4.58.0504201237340.6467@ppc970.osdl.org>
References: <200504191250.10286.mason@suse.com> <200504201323.05447.mason@suse.com>
 <Pine.LNX.4.58.0504201040400.6467@ppc970.osdl.org> <200504201504.59541.mason@suse.com>
 <Pine.LNX.4.58.0504201218360.6467@ppc970.osdl.org>
Mime-Version: 1.0
Content-Type: TEXT/PLAIN; charset=US-ASCII
Cc: git@vger.kernel.org
X-From: git-owner@vger.kernel.org Wed Apr 20 21:42:15 2005
Return-path: <git-owner@vger.kernel.org>
Received: from vger.kernel.org ([12.107.209.244])
	by ciao.gmane.org with esmtp (Exim 4.43)
	id 1DOL5G-0000J8-EO
	for gcvg-git@gmane.org; Wed, 20 Apr 2005 21:42:02 +0200
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S261753AbVDTTqQ (ORCPT <rfc822;gcvg-git@m.gmane.org>);
	Wed, 20 Apr 2005 15:46:16 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S261743AbVDTTqQ
	(ORCPT <rfc822;git-outgoing>); Wed, 20 Apr 2005 15:46:16 -0400
Received: from fire.osdl.org ([65.172.181.4]:10123 "EHLO smtp.osdl.org")
	by vger.kernel.org with ESMTP id S261753AbVDTTqF (ORCPT
	<rfc822;git@vger.kernel.org>); Wed, 20 Apr 2005 15:46:05 -0400
Received: from shell0.pdx.osdl.net (fw.osdl.org [65.172.181.6])
	by smtp.osdl.org (8.12.8/8.12.8) with ESMTP id j3KJk1s4026985
	(version=TLSv1/SSLv3 cipher=EDH-RSA-DES-CBC3-SHA bits=168 verify=NO);
	Wed, 20 Apr 2005 12:46:01 -0700
Received: from localhost (shell0.pdx.osdl.net [10.9.0.31])
	by shell0.pdx.osdl.net (8.13.1/8.11.6) with ESMTP id j3KJk0RS024058;
	Wed, 20 Apr 2005 12:46:00 -0700
To: Chris Mason <mason@suse.com>
In-Reply-To: <Pine.LNX.4.58.0504201218360.6467@ppc970.osdl.org>
X-Spam-Status: No, hits=0 required=5 tests=
X-Spam-Checker-Version: SpamAssassin 2.63-osdl_revision__1.35__
X-MIMEDefang-Filter: osdl$Revision: 1.109 $
X-Scanned-By: MIMEDefang 2.36
Sender: git-owner@vger.kernel.org
Precedence: bulk
X-Mailing-List: git@vger.kernel.org
Status: RO



On Wed, 20 Apr 2005, Linus Torvalds wrote:
>
> It would be nicer for the cache to make the index file "header" be a 
> "footer", and write it out last - that way we'd be able to do the SHA1 as 
> we write rather than doing a two-pass thing. That's for another time.

That other time was now.

The header is still a header, but the sha1 is now at the end of the file, 
which means that the header version has been incremented by 1 (to 2).

This is also sadly an incompatible change, so once you update and install
the new tools, you'll need to do

	tree=$(cat-file commit $(cat .git/HEAD) | sed 's/tree //;q')
	read-tree $tree
	update-cache --refresh

to re-build your index file.

Sorry about that, but the end result should be quite fast (especially if
your sha1 is fast). The best benchmark is probably to just do a "time
update-cache Makefile" in the kernel (before and after), when the cache
was already up-to-date and with no time spent on stating lots of files.  
That kind of "one file changed" timing is actually the common case (in
this case Makefile won't have changed, but update-cache doesn't care).

(Of course, I could optimize it to notice that the update-cache didn't do
anything and avoid the write altogether, but that's likely optimizing for
the wrong case, since normally you'd call update-cache when you know
something changed).

Yeah, it's somewhat silly doing optimizations at this point, but I want to
make sure that the data structures are all ready for a real release, and
as part of that I want to make sure there are no stupid low-hanging fruit
that we'll curse later. Better get it done with now.

			Linus
-
To unsubscribe from this list: send the line "unsubscribe git" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html



