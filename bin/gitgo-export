#!/usr/bin/env ruby
begin
require 'optparse'
require 'fileutils'

full = false
preview = false
OptionParser.new do |opts|
  opts.banner = %{
usage: gitgo-export [-f] [-h] [-p]

  Exports gitgo branches in the format used by git-fast-import.

options:
}.lstrip

  opts.on("-f", "full export") do
    full = true
  end

  opts.on("-h", "print this help") do
    puts opts
    puts
    exit
  end

  opts.on("-p", "preview - do not update marks") do
    preview = true
  end
end.parse!

args = ARGV.dup
ARGV.clear

#############################################################################
class Entry
  attr_accessor :sha, :commit, :mark, :author, :committer, :body, :meta, :tree
  attr_reader :marks, :tags, :remap

  LEADER = "---\n"

  def initialize(marks = {})
    reset
    @marks = marks
    @tags  = Hash.new {|hash, key| hash[key] = [] }
    @remap = {}
  end

  def reset
    @sha, @commit, @mark, @author, @committer, @body = nil
    @tree = []
    @meta = []
  end

  def read(io = $stdin)
    reset

    while line = io.gets
      break if line == "\n"

      key, value = line.split(' ', 2)

      case key
      when "commit"
        @commit = value
      when "mark"
        @mark = value
        @sha  = marks[mark.chomp]
      when "author"
        @author = value
      when "committer"
        @committer = value
      when "data"
        @body = io.read(value.chomp.to_i)

        if body =~ /(.*)#{LEADER}([+-:] .*\n)*\z/m
          @body = $1
          @meta = $2.to_s.split("\n")
        end

      when "from", "merge"
        next
      else
        tree << line
      end
    end

    commit && (author || committer) && body ? true : false
  end

  def write(io = $stdout)
    return if meta.nil?

    parents = []
    meta.each do |line|
      type, value = line.split(' ', 2)

      case type
      when "+" then parents << value
      when ":" then tags[value] << sha
      when "-" then remap[value] = sha
      else raise "invalid metadata: #{line}"
      end
    end

    io.print "commit #{commit}\n"
    io.print "mark #{mark}" if mark
    io.print "author #{author}" if author
    io.print "committer #{committer}" if committer
    io.print "data #{body.length}\n"
    io.print body

    if parent = parents.shift
    io.print "from #{marks[parent]}\n"
    end

    parents.each do |parent|
    io.print "merge #{marks[parent]}\n"
    end

    io.puts
  end
end

gitgo_dir = ENV['GITGO_DIR'] || File.join(`git rev-parse --git-dir`.chomp("\n"), 'gitgo')
export_dir = File.expand_path("export", gitgo_dir)
marks_file  = File.join(export_dir, "marks")
export_file = File.join(export_dir, "file")

if full && File.exists?(marks_file)
  FileUtils.rm marks_file
end

unless File.exists?(export_dir)
  FileUtils.mkdir_p export_dir
end

FileUtils.touch marks_file

`git fast-export --import-marks='#{marks_file}' --export-marks='#{preview ? '/dev/null' : marks_file}' gitgo > '#{export_file}'`

marks = {}
File.open(marks_file) do |io|
  io.each_line do |line|
    mark, sha = line.split
    marks[sha] = mark
    marks[mark] = sha
  end
end

File.open(export_file) do |io|
  entry = Entry.new(marks)
  while entry.read(io)
    entry.commit = "refs/heads/gitgo-import"
    entry.write
  end
end

File.unlink export_file

#############################################################################
rescue Interrupt
  exit 130
rescue Errno::EPIPE 
  exit 0
rescue
  raise if $DEBUG
  $stderr.puts $!.message
  exit 1
end