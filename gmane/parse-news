#!/bin/bash
############################################################################
usage="\
usage: parse-news [-a] [-h] [FILE...]

  Parses the gmane archive html into a textual topography. Reads from stdin
  if FILE is a single dash or no files are specified. Combine with download
  for quick results.

    fetch-news gmane.comp.version-control.git 0 1 2 | parse-news

  Produces something like:

    1205 -- Colorized git log
    `- 1208 -- Colorized git log
     `- 1224 -- [PATCH] Colorized git log
      `- 1225 -- [PATCH] Colorized git log
       |- 1227 -- [PATCH] Colorized git log
       `- 1226 -- [PATCH] Colorized git log

  Printing arcs flattens this graph to parent/child relations:

    1205 1208
    1208 1224
    1224 1225
    1225 1227
    1225 1226

options:

        -a    prints arc relations
        -h    prints this help

"
############################################################################

while getopts "ah" option
do
  case $option in
    a  )  arcs="true" ;;
    h  )  printf "$usage"
          exit 0 ;;
    \? )  printf "$usage" | head -n 1
          exit 2 ;;
  esac
done
shift $(($OPTIND - 1))

############################################################################

# read files
cat $@ |

# pull out topography and article numbers
sed -e '
/^<tr/!d
s/src/\
src/g
s/href/\
href/g
' |

# rebuilt the topography as text
sed -ne '
/src/ {
  s:src="/short/b+l.png".*:   :
  s:src="/short/I+l.png".*:|  :
  s:src="/short/T+l.png".*:|- :
  s:src="/short/L+l.png".*:`- :
  s:src.*::
  H
}
/href/ {
  s/[^0-9]*\([0-9]*\)" .*">\(.*\)<\/a.*/\1 -- \2/
  # join all the topography segments 
  H
  s/.*//
  x
  s/\n//g
  # delimit threads with a newline
  s/^\([0-9]\)/\
\1/
  # print it out!
  p
}
' |

# flatten the graph to arcs
if [ "$arcs" == "true" ]
then ruby -e '
stack = []
while line = gets
  if line =~ /^(.*?)(\d+)/
    depth, num = ($1.length / 3), $2

    while stack.length > depth
      stack.pop
    end
    stack << num

    if stack.length >= 2
      puts "#{stack[-2]} #{stack[-1]}"
    end
  end
end
'
else cat
fi
