#!/bin/bash
############################################################################
usage="\
usage: parse-news [-ghlr] [FILE...]

  Parses the gmane archive html into a textual topography. Reads from stdin
  if FILE is a single dash or no files are specified. Combine with download
  for quick results.

    fetch-news gmane.comp.version-control.git 0 1 2 | parse-news

  Produces something like:

    1205 -- Colorized git log
    \`- 1208 -- Colorized git log
     \`- 1224 -- [PATCH] Colorized git log
      \`- 1225 -- [PATCH] Colorized git log
       |- 1227 -- [PATCH] Colorized git log
       \`- 1226 -- [PATCH] Colorized git log

  Other modes can list all the nodes (-l), list the nodes as ranges (-r) or
  flatten the graph to parent/child relations (-g):

    1205 1208
    1208 1224
    1224 1225
    1225 1227
    1225 1226

options:

        -g    print graph relations
        -h    prints this help
        -l    list message ids
        -r    list messages as ranges

"
############################################################################

mode=""
while getopts "ghlr" option
do
  case $option in
    g  )  mode="graph" ;;
    h  )  printf "$usage"
          exit 0 ;;
    l  )  mode="list" ;;
    r  )  mode="range" ;;
    \? )  printf "$usage" | head -n 1
          exit 2 ;;
  esac
done
shift $(($OPTIND - 1))

############################################################################

# read files
cat $@ |

# pull out topography and article numbers
sed -e '
/^<tr/!d
s/src/\
src/g
s/href/\
href/g
' |

# rebuilt the topography as text
sed -ne '
/src/ {
  s:src="/short/b+l.png".*:   :
  s:src="/short/I+l.png".*:|  :
  s:src="/short/T+l.png".*:|- :
  s:src="/short/L+l.png".*:`- :
  s:src.*::
  H
}
/href/ {
  s/[^0-9]*\([0-9]*\)" .*">\(.*\)<\/a.*/\1 -- \2/
  # join all the topography segments 
  H
  s/.*//
  x
  s/\n//g
  # delimit threads with a newline
  s/^\([0-9]\)/\
\1/
  # print it out!
  p
}
' |

# flatten the graph to arcs
if [ "$mode" == "graph" ]
then ruby -e '
stack = []
while line = gets
  if line =~ /^(.*?)(\d+)/
    depth, num = ($1.length / 3), $2

    while stack.length > depth
      stack.pop
    end
    stack << num

    if stack.length >= 2
      puts "#{stack[-2]} #{stack[-1]}"
    end
  end
end
'

elif [ "$mode" == "list" ]
then awk -F '--' '/./ {print $1}' | tr -cd "[0-9]\n"

elif [ "$mode" == "range" ]
then sed -ne 's/[^0-9]*\([0-9]\{1,\}\).*/\1/p' | sort -n | ruby -e '
previous = nil
while line = gets
  unless line =~ /^\d+$/
    raise "not an integer: #{line}"
  end

  current = line.to_i

  unless current - 1 == previous
    print "#{previous}\n" if previous
    print "#{current} "
  end

  previous = current
end

if previous
  print "#{previous}\n" 
end
'
else cat
fi
